<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>cpp/string.cpp</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top"> </A>
<A NAME="file1"> </A>
<H1><a href="string.cpp">string.cpp</a></H1>

<PRE>
<I><FONT COLOR="#B22222">// -*- Mode:C++; Coding:us-ascii-unix; fill-column:132 -*-
</FONT></I><I><FONT COLOR="#B22222">/**********************************************************************************************************************************/</FONT></I>
<I><FONT COLOR="#B22222">/**
   @file      string.cpp
   @author    Mitch Richling &lt;http://www.mitchr.me&gt;
   @Copyright Copyright 2000 by Mitch Richling.  All rights reserved.
   @brief     Example of how to use strings in C++ 98.@EOL
   @Keywords  Standard C++ STL string
   @Std       C++98

   While string is NOT part of the STL as a container, it is very container-like.
***********************************************************************************************************************************/</FONT></I>

<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string&gt;</FONT></B>                  <I><FONT COLOR="#B22222">/* C++ strings             C++98/11 */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;iostream&gt;</FONT></B>                <I><FONT COLOR="#B22222">/* C++ iostream            C++98/11 */</FONT></I>

<I><FONT COLOR="#B22222">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
  <I><FONT COLOR="#B22222">// strings start life empty with the default constructor
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::string s1, s2, s3;

  <I><FONT COLOR="#B22222">// strings may be constructed from c-strings like so
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::string s4(<B><FONT COLOR="#BC8F8F">&quot;hello&quot;</FONT></B>);
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::string s5(<B><FONT COLOR="#BC8F8F">&quot;12345678901234567890&quot;</FONT></B>);

  <I><FONT COLOR="#B22222">// You can assign a c-string to a string
</FONT></I>  s1 = <B><FONT COLOR="#BC8F8F">&quot;HAL&quot;</FONT></B>;

  <I><FONT COLOR="#B22222">// operator+ is overridden and understands strings AND c-strings so that the two can be freely intermixed:
</FONT></I>  s2 = s4 + <B><FONT COLOR="#BC8F8F">&quot; my name is &quot;</FONT></B> + s1;

  <I><FONT COLOR="#B22222">// You can also use += like this:
</FONT></I>  s2 += <B><FONT COLOR="#BC8F8F">&quot;!&quot;</FONT></B>;
  
  <I><FONT COLOR="#B22222">// Or you can append like this.
</FONT></I>  s2.append(<B><FONT COLOR="#BC8F8F">&quot;!&quot;</FONT></B>);

  <I><FONT COLOR="#B22222">// Be careful and don't try to add two c-strings.  The following would not generally work: s3 = &quot;I &quot; + &quot;like &quot; + s1; Do
</FONT></I>  <I><FONT COLOR="#B22222">// something like this to get around the problem:
</FONT></I>  s3 = std::string(<B><FONT COLOR="#BC8F8F">&quot;I &quot;</FONT></B>) + <B><FONT COLOR="#BC8F8F">&quot;like &quot;</FONT></B> + s1;

  <I><FONT COLOR="#B22222">// cout knows how to print both c-strings and strings;
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Strings at this point:&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;  s1='&quot;</FONT></B> &lt;&lt; s1 &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;  s2='&quot;</FONT></B> &lt;&lt; s2 &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;  s3='&quot;</FONT></B> &lt;&lt; s3 &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;  s4='&quot;</FONT></B> &lt;&lt; s4 &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;  s5='&quot;</FONT></B> &lt;&lt; s5 &lt;&lt;  <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// The length of a string may be found with length():
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;The length of s5=&quot;</FONT></B> &lt;&lt; s5.length() &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// Substrings are easy:
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;The s5.substr(3,7):='&quot;</FONT></B> &lt;&lt; s5.substr(3, 7) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// Strings may be indexed like arrays.
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;char 3 of s5 (s5[2])='&quot;</FONT></B> &lt;&lt; s5[2] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// Assignment works too so long as the char type has =:
</FONT></I>  s5[2] = <B><FONT COLOR="#BC8F8F">'X'</FONT></B>;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;After s5[2]='X', s5='&quot;</FONT></B> &lt;&lt; s5 &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;'&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// You can erase and collapse substrings:
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;The s5.erase(3,7):='&quot;</FONT></B> &lt;&lt; s5.erase(3, 7) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' (now only &quot;</FONT></B> &lt;&lt; 
	s5.length() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; chars)&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// You can insert strings, substrings, c-strings, and characters.
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;After s5.insert(5, 'YYYY'):='&quot;</FONT></B>    &lt;&lt; s5.insert(5, <B><FONT COLOR="#BC8F8F">&quot;YYYY&quot;</FONT></B>)    &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' (now at &quot;</FONT></B> &lt;&lt; s5.length() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; chars)&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;After s5.insert(7, 'Z'):='&quot;</FONT></B>       &lt;&lt; s5.insert(7, <B><FONT COLOR="#BC8F8F">&quot;Y&quot;</FONT></B>)       &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' (now at &quot;</FONT></B> &lt;&lt; s5.length() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; chars)&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;After s5.insert(10, s4):='&quot;</FONT></B>       &lt;&lt; s5.insert(10, s4)       &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' (now at &quot;</FONT></B> &lt;&lt; s5.length() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; chars)&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;After s5.insert(10, s4, 2, 2):='&quot;</FONT></B> &lt;&lt; s5.insert(10, s4, 2, 2) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;' (now at &quot;</FONT></B> &lt;&lt; s5.length() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; chars)&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// If your char is equality comparable, then so are strings.  The == operator also knows what to do with c-strings.
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B>(s1 == <B><FONT COLOR="#BC8F8F">&quot;HAL&quot;</FONT></B>)
	<B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;TRUE:  s1=='HAL'&quot;</FONT></B> &lt;&lt; std::endl;
  <B><FONT COLOR="#A020F0">if</FONT></B>( !(s1 == <B><FONT COLOR="#BC8F8F">&quot;hAL&quot;</FONT></B>))
	<B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;FALSE: s1=='hAL'&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// If your char is LessThan comparable, then so are strings.  The operators deal with c-strings. (all work: &lt; &gt; &lt;= &gt;=)
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B>(s1 &lt; <B><FONT COLOR="#BC8F8F">&quot;hal&quot;</FONT></B>)
	<B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;TRUE:  s1&lt;'hal'&quot;</FONT></B> &lt;&lt; std::endl;

  <I><FONT COLOR="#B22222">// It is easy to search for substrings within strings.  
</FONT></I>  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;s3.find('HAL')=&quot;</FONT></B> &lt;&lt; s3.find(<B><FONT COLOR="#BC8F8F">&quot;HAL&quot;</FONT></B>) &lt;&lt; std::endl;
  <B><FONT COLOR="#5F9EA0">std</FONT></B>::cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;s3.find('hAL')=&quot;</FONT></B> &lt;&lt; s3.find(<B><FONT COLOR="#BC8F8F">&quot;hAL&quot;</FONT></B>) &lt;&lt; std::endl;
} <I><FONT COLOR="#B22222">// end func main
</FONT></I></PRE>
<HR \/>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>
</HTML>
